(*
Copyright 2018

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*)
theory buddy_opt
  imports "../../../isabelle/Simplified_Semantics" (* for the bitvector lemmas *)
          reassembly_all_execution_debug.More_Eisbach_Tools
          "HOL-Library.Rewrite"
          "../../../isabelle/Monads/Abstract_System"
begin

abbreviation \<open>RDI \<sigma> \<equiv> regs \<sigma> rdi\<close>
abbreviation \<open>RSP \<sigma> \<equiv> regs \<sigma> rsp\<close>
abbreviation \<open>DIL \<sigma> \<equiv> \<langle>7,0\<rangle>regs \<sigma> rdi :: 8 word\<close>

text \<open>buddy_t is a union of struct{uint8;uint16;} with a pointer, so 8 bytes\<close>
abbreviation \<open>SIZEOF_BUDDY \<equiv> 8::nat\<close>
abbreviation \<open>BUDDY_MAX \<equiv> 32::nat\<close>
abbreviation \<open>BUDDY_MIN \<equiv> 6::nat\<close>
abbreviation \<open>BUDDY_ALLOC \<equiv> 16::nat\<close>
abbreviation \<open>BUDDY_LISTS \<equiv> BUDDY_MAX - BUDDY_MIN + 1\<close>
abbreviation \<open>BUDDY_MAGIC \<equiv> 0xBABE::nat\<close> \<comment> \<open>Might be better off as @{typ \<open>16 word\<close>} or @{typ \<open>32 word\<close>}\<close>

text \<open>
  For now, we simply pretend palloc returns some address from the full range of possible addresses.
  Of course, it should actually be an address that is currently unused, but I don't know the best
  way to illustrate that yet, maybe  can help at some point given he was working on modeling
  malloc.
\<close>
fun palloc :: \<open>state \<Rightarrow> state\<close> where
  \<open>palloc \<sigma> = \<sigma>\<lparr>regs := (regs \<sigma>)(rax := \<some>_. True)\<rparr>\<close>

(*5 flags generation CF,SF,OF,ZF,PF *)
instruction_semantics_parser "../InstructionSemantics/strata_rules_5flags"
lemmas strata_rules_5flags.semantics_def[code]

text \<open>
  A Floyd invariant is a partial map from locations to state predicates.
  A location consists of a tuple (ts, pc) which stores the current text section and the program
  counter.
\<close>
type_synonym floyd_invar = \<open>(int \<times> int) \<rightharpoonup> (state \<Rightarrow> bool)\<close>

text \<open>Load the buddy-opt.s file.\<close>
x86_64_parser "../examples/hermitcore/malloc_buddy/buddy-opt.s"

lemmas "buddy-opt.assembly_def"[code]

text \<open>
  We use a locale to quantify over any @{term l}, i.e, any assignment of addresses to labels.
  This locale extends the locale generated by the parser.
\<close>
locale assembly = "buddy-opt" + execution_context + strata_rules_5flags +
  assumes \<alpha>_def: \<open>\<alpha> \<equiv> assembly\<close>
      and palloc[simp]: \<open>funcs ''palloc'' \<equiv> Some palloc\<close>
      and [simp]: \<open>label_to_index \<alpha> ''buddy_get'' = Some (5, 1)\<close> \<comment> \<open>This needs to be generated.\<close>
      and [simp]: \<open>label_to_index \<alpha> ''buddy_large_avail'' = Some (1, 1)\<close> \<comment> \<open>This needs to be generated.\<close>
      and [simp]: \<open>funcs ''buddy_get'' = None\<close> \<comment> \<open>This shouldn't be necessary but is right now due to how Call checks for functions.\<close>
      and [simp]: \<open>funcs ''buddy_large_avail'' = None\<close>
      and [simp]: \<open>address_to_label (98 + l ''buddy_get'') = Some ''.buddy_large_avail_ret''\<close> \<comment> \<open>Temporary fix until  gets a proper function set up; not sure if it's even necessary right now, though.\<close>
begin

lemma unfold_\<alpha>[simp]:
  shows \<open>text_sections \<alpha> = text_sections assembly\<close>
    and \<open>data_sections \<alpha> = data_sections assembly\<close>
    and \<open>labels_to_addresses \<alpha> = labels_to_addresses assembly\<close>
    and \<open>labels_to_indices \<alpha> = labels_to_indices assembly\<close>
  unfolding \<alpha>_def
  by simp+

label_simp_rules [
  ".label_14", ".label_15", ".label_16", (* buddy_large_avail *)
  ".label_17", ".label_18", (* buddy_exp *)
  ".label_19", ".label_20", ".label_21", ".label_22", ".label_23", ".label_24", ".label_25", ".label_26", ".label_27", ".label_28", ".label_29", (* buddy_get *)
  "buddy_lists", "label_26a",
  ".buddy_large_avail_ret", ".palloc_ret", ".buddy_get_ret"
]
  by (auto simp add: label_to_index_def label_to_address_def assembly_def assembly.defs(1) text_section.defs(1))

abbreviation \<open>buddy_lists \<equiv> the (label_to_address l \<alpha> ''buddy_lists'')\<close>

schematic_goal unfold_semantics:
  shows \<open>instr_semantics semantics instr_sig = ?x\<close>
  by (simp add: semantics_def simp_rules)

fun buddy_opt_flag_annotation :: flag_annotation where
  \<open>buddy_opt_flag_annotation _ = {}\<close>

text \<open>
  The step function fetches the next instruction and executes it.
  This matches exactly what method rewrite\_one\_instruction is able to rewrite.
  Need to switch to learned semantics rather than manual eventually?
\<close>
definition step :: \<open>(unit, state) se\<close> where
  \<open>step \<sigma> \<equiv>
    let' t = text_sections \<alpha>!(nat (ts \<sigma>));
         i = instructions t!(nat (pc \<sigma>));
         \<sigma> = exec_instr buddy_opt_flag_annotation semantics i \<sigma>
    in
      Some ((), \<sigma>)\<close>

lemma wps_stepI[wps_intros]:
  assumes \<open>let' t = text_sections \<alpha>!(nat (ts \<sigma>));
                i = instructions t!(nat (pc \<sigma>));
                \<sigma> = exec_instr buddy_opt_flag_annotation semantics i \<sigma>
           in
             Q () \<sigma>\<close>
  shows \<open>wps step Q \<sigma>\<close>
  using assms
  unfolding step_def
  by (auto simp add: Let'_def Let_def wps_def)

definition wf_state :: \<open>state \<Rightarrow> bool\<close> where
  \<open>wf_state _ = True\<close>

definition location :: \<open>state \<Rightarrow> int \<times> int\<close> where
  \<open>location \<sigma> \<equiv> (ts \<sigma>, pc \<sigma>)\<close>

definition until :: \<open>(int \<times> int) set \<Rightarrow> state \<Rightarrow> bool\<close>
  where \<open>until H \<sigma> \<equiv> \<exists>(ts\<^sub>H, pc\<^sub>H) \<in> H. location \<sigma> = (ts\<^sub>H, pc\<^sub>H - 1)\<close>

text \<open>
   suggested @{text \<open>(sublist n m xs = []) = (Suc m \<le> n \<or> length xs \<le> n)\<close>} for efficiency, but
  that unfortunately doesn't work.
\<close>
lemma sublist_empty: (* TODO: move elsewhere eventually *)
  assumes \<open>n \<ge> length xs\<close>
    and \<open>m \<ge> length xs\<close>
  shows \<open>sublist n m xs = []\<close>
  using assms unfolding sublist_def
  by simp

section \<open>Fixed @{text find_masters} stuff\<close>
text \<open>
  's enclosed_plus stuff didn't really work, and for @{text find_masters} it seems that
  using @{text unat_arith} doesn't need to do much work, so I'm sticking with that for now. This
  stuff should be merged into @{theory reassembly_all_execution_debug.Memory_Rewriting} eventually,
  but I'm avoiding doing so for now to avoid any messy merge conflicts later.
\<close>
lemma no_block_overflow_smaller_block:
  assumes \<open>no_block_overflow (a, s)\<close>
      and \<open>s' \<le> s\<close>
    shows \<open>no_block_overflow (a, s')\<close>
  using assms
  by (simp add: no_block_overflow.simps)

method find_master_larger_block uses assms add =
  match conclusion in \<open>master blocks (a, s) i\<close> for blocks a s i \<Rightarrow> \<open>
    match assms in A: \<open>(i, a, s') \<in> blocks\<close> for s' \<Rightarrow> \<open>
      match assms in B: \<open>seps blocks\<close> \<Rightarrow> \<open>
        rule master_of_enclosed[OF B _ A],
        rule no_block_overflow_smaller_block[of a s'],
        rule seps_implies_no_block_overflow[OF B A],
        simp add: add,
        insert seps_implies_no_block_overflow[OF B A],
        simp add: add enclosed.simps no_block_overflow.simps,
        unat_arith,
        auto
      \<close>
    \<close>
  \<close>

method find_master_larger_block_positive_offset_r' uses assms add =
  match conclusion in \<open>master blocks (a + offset, s) i\<close> for blocks a offset s i \<Rightarrow> \<open>
    match assms in A: \<open>(i, a, s') \<in> blocks\<close> for s' \<Rightarrow> \<open>
      match assms in B: \<open>seps blocks\<close> \<Rightarrow> \<open>
        rule master_of_enclosed[OF B _ A],
        rule no_block_overflow_smaller_block_positive_offset_r[of a s'],
        rule seps_implies_no_block_overflow[OF B A],
        simp add: add,
        insert seps_implies_no_block_overflow[OF B A],
        simp add: add enclosed.simps no_block_overflow.simps,
        unat_arith,
        auto
      \<close>
    \<close>
  \<close>

method find_master' uses assms add =
    find_master_same_block assms: assms
  | find_master_larger_block assms: assms
  | find_master_larger_block_negative_offset    assms: assms add: add
  | find_master_larger_block_positive_offset    assms: assms add: add \<comment> \<open>May need a fixed version too\<close>
  | find_master_larger_block_positive_offset_r' assms: assms add: add

end

declare plus_less_left_cancel_nowrap[simp add]
lemma x_less_x_plus_y[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
  shows \<open>x \<le> x + y\<close>
  apply (rule plus_minus_no_overflow_ab[of x "max_word::'a::len word" y,OF assms])
  by auto
lemma x_plus_y_less_x[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
    and \<open>y > 0\<close>
  shows \<open>x + y \<le> x \<longleftrightarrow> False\<close>
  using assms x_less_x_plus_y
  by fastforce
lemma less_max_word_minus[simp]:
  fixes x y z :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
     and \<open>y \<ge> z\<close>
   shows \<open>x \<le> max_word - z\<close>
  apply (rule order_trans[OF assms(1)])
  using assms
  by simp
lemma plus_lt_left_cancel_nowrap[simp]: \<open>x \<le> x + y' \<Longrightarrow> x \<le> x + y \<Longrightarrow> x + y' < x + y \<longleftrightarrow> y' < y\<close>
  for x y y' :: \<open>'a::len0 word\<close>
  by uint_arith
lemma plus_lt_right_cancel_nowrap[simp]: \<open>x \<le> x + y' \<Longrightarrow> x \<le> x + y \<Longrightarrow> y' + x < y + x \<longleftrightarrow> y' < y\<close>
  for x y y' :: \<open>'a::len0 word\<close>
  by uint_arith
lemma x_lt_x_plus_y[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
    shows \<open>x < x + y \<longleftrightarrow> y > 0\<close>
proof -
  have \<open>x \<le> x + y\<close>
    apply (rule plus_minus_no_overflow_ab[of x \<open>max_word::'a::len word\<close> y, OF assms(1)])
    by auto
  thus ?thesis
    apply (auto simp add: word_le_less_eq)
    by uint_arith
qed
lemma unfold_enclosed_same_block:
  \<open>(a + offset, s) \<sqsubseteq> (a + offset', s') \<longleftrightarrow> a + offset' \<le> a + offset \<and> a + offset + of_nat s \<le> a + offset' + of_nat s'\<close>
  by (auto simp add: enclosed.simps)
lemmas unfold_enclosed_same_block_0l[simp] = unfold_enclosed_same_block[where offset=0,simplified]
lemmas unfold_enclosed_same_block_0r[simp] = unfold_enclosed_same_block[where offset'=0,simplified]
declare linorder_class.not_le[simp add]

lemma unfold_enclosed_same_block_minus:
  \<open>(a - offset, s) \<sqsubseteq> (a - offset', s') \<longleftrightarrow> a - offset' \<le> a - offset \<and> a - offset + of_nat s \<le> a - offset' + of_nat s'\<close>
  by (auto simp add: enclosed.simps)
lemmas unfold_enclosed_same_block_minus_0l[simp] = unfold_enclosed_same_block_minus[where offset=0,simplified]
lemmas unfold_enclosed_same_block_minus_0r[simp] = unfold_enclosed_same_block_minus[where offset'=0,simplified]

lemma (in execution_context) no_overflow_explicit[simp]:
  assumes \<open>master blocks (a, unat s) i\<close>
   and \<open>a = a'\<close>
 shows \<open>a' \<le> max_word - s\<close>
proof -
  have \<open>no_block_overflow (a', unat s)\<close>
    using assms
    by (simp add: master_block_implies_no_block_overflow')
  then show ?thesis
    using assms
    by (simp add: no_block_overflow.simps max_word_eq) unat_arith
qed

context execution_context
begin

lemmas sub_overflow_flag_simps[simp] =
  sub_overflow_flag_def[of 0 0]
  sub_overflow_flag_def[of 0 1]
  sub_overflow_flag_def[of 0 \<open>numeral m\<close>]
  sub_overflow_flag_def[of 1 0]
  sub_overflow_flag_def[of 1 1]
  sub_overflow_flag_def[of 1 \<open>numeral m\<close>]
  sub_overflow_flag_def[of \<open>numeral n\<close> 0]
  sub_overflow_flag_def[of \<open>numeral n\<close> 1]
  sub_overflow_flag_def[of \<open>numeral n\<close> \<open>numeral m\<close>]
  for n m

lemmas sub_sign_flag_simps[simp] =
  sub_sign_flag_def[of 0 0]
  sub_sign_flag_def[of 0 1]
  sub_sign_flag_def[of 0 \<open>numeral m\<close>]
  sub_sign_flag_def[of 1 0]
  sub_sign_flag_def[of 1 1]
  sub_sign_flag_def[of 1 \<open>numeral m\<close>]
  sub_sign_flag_def[of \<open>numeral n\<close> 0]
  sub_sign_flag_def[of \<open>numeral n\<close> 1]
  sub_sign_flag_def[of \<open>numeral n\<close> \<open>numeral m\<close>]
  for n m
end

end
