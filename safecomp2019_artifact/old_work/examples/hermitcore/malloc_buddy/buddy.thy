(*
Copyright 2018

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*)
theory buddy
  imports "../../../isabelle/Simplified_Semantics" (* for the bitvector lemmas *)
          reassembly_all_execution_debug.More_Eisbach_Tools
          "HOL-Library.Rewrite"
          "../../../isabelle/Monads/Abstract_System"
begin

abbreviation \<open>RDI \<sigma> \<equiv> regs \<sigma> rdi\<close>
abbreviation \<open>EDI \<sigma> \<equiv> \<langle>31,0\<rangle>regs \<sigma> rdi :: 32 word\<close>
abbreviation \<open>RSI \<sigma> \<equiv> regs \<sigma> rsi\<close>
abbreviation \<open>ESI \<sigma> \<equiv> \<langle>31,0\<rangle>regs \<sigma> rsi :: 32 word\<close>
abbreviation \<open>RAX \<sigma> \<equiv> regs \<sigma> rax\<close>
abbreviation \<open>EAX \<sigma> \<equiv> \<langle>31,0\<rangle>regs \<sigma> rax :: 32 word\<close>
abbreviation \<open>RCX \<sigma> \<equiv> regs \<sigma> rcx\<close>
abbreviation \<open>ECX \<sigma> \<equiv> \<langle>31,0\<rangle>regs \<sigma> rcx :: 32 word\<close>
abbreviation \<open>RDX \<sigma> \<equiv> regs \<sigma> rdx\<close>
abbreviation \<open>EDX \<sigma> \<equiv> \<langle>31,0\<rangle>regs \<sigma> rdx :: 32 word\<close>
abbreviation \<open>RBP \<sigma> \<equiv> regs \<sigma> rbp\<close>
abbreviation \<open>RSP \<sigma> \<equiv> regs \<sigma> rsp\<close>

text \<open>buddy_t is a union of struct{uint8;uint16;} with a pointer, so 8 bytes\<close>
abbreviation \<open>SIZEOF_BUDDY \<equiv> 8::nat\<close>
abbreviation \<open>BUDDY_MAX \<equiv> 32::nat\<close>
abbreviation \<open>BUDDY_MIN \<equiv> 6::nat\<close>
abbreviation \<open>BUDDY_ALLOC \<equiv> 16::nat\<close>
abbreviation \<open>BUDDY_LISTS \<equiv> BUDDY_MAX - BUDDY_MIN + 1\<close>
abbreviation \<open>BUDDY_MAGIC \<equiv> 0xBABE::nat\<close> \<comment> \<open>Might be better off as @{typ \<open>16 word\<close>} or @{typ \<open>32 word\<close>}\<close>

text \<open>
  For now, we simply pretend palloc returns some address from the full range of possible addresses.
  Of course, it should actually be an address that is currently unused, but I don't know the best
  way to illustrate that yet, maybe  can help at some point given he was working on modeling
  malloc.
\<close>
fun palloc :: \<open>state \<Rightarrow> state\<close> where
  \<open>palloc \<sigma> = \<sigma>\<lparr>regs := (regs \<sigma>)(rax := \<some>_. True)\<rparr>\<close>

(*5 flags generation CF,SF,OF,ZF,PF *)
instruction_semantics_parser "../InstructionSemantics/strata_rules_5flags"
lemmas strata_rules_5flags.semantics_def[code]

text \<open>
  A Floyd invariant is a partial map from locations to state predicates.
  A location consists of a tuple (ts, pc) which stores the current text section and the program
  counter.
\<close>
type_synonym floyd_invar = \<open>(int \<times> int) \<rightharpoonup> (state \<Rightarrow> bool)\<close>

text \<open>Load the buddy.s file.\<close>
x86_64_parser "../examples/hermitcore/malloc_buddy/buddy.s"

lemmas buddy.assembly_def[code]

text \<open>
  We use a locale to quantify over any @{term l}, i.e, any assignment of addresses to labels.
  This locale extends the locale generated by the parser.
\<close>
locale assembly = buddy + execution_context + strata_rules_5flags +
  assumes \<alpha>_def: \<open>\<alpha> \<equiv> assembly\<close>
      and palloc[simp]: \<open>funcs ''palloc'' \<equiv> Some palloc\<close>
      and [simp]: \<open>label_to_index \<alpha> ''buddy_get'' = Some (2, 1)\<close> \<comment> \<open>This needs to be generated.\<close>
      and [simp]: \<open>label_to_index \<alpha> ''buddy_large_avail'' = Some (0, 1)\<close> \<comment> \<open>This needs to be generated.\<close>
      and [simp]: \<open>funcs ''buddy_get'' = None\<close> \<comment> \<open>This shouldn't be necessary but is right now due to how Call checks for functions.\<close>
      and [simp]: \<open>funcs ''buddy_large_avail'' = None\<close>
begin

lemma unfold_\<alpha>[simp]:
  shows \<open>text_sections \<alpha> = text_sections assembly\<close>
    and \<open>data_sections \<alpha> = data_sections assembly\<close>
    and \<open>labels_to_addresses \<alpha> = labels_to_addresses assembly\<close>
    and \<open>labels_to_indices \<alpha> = labels_to_indices assembly\<close>
  unfolding \<alpha>_def
  by simp+

label_simp_rules ["label_11", "label_12", "label_13", (* buddy_large_avail *)
    ".label_14", ".label_15", ".label_16", ".label_17", (* buddy_exp *)
    ".label_18", ".label_19", ".label_20", ".label_21", (* buddy_get *)
    "buddy_lists"]
  by (auto simp add: label_to_index_def label_to_address_def assembly_def assembly.defs(1) text_section.defs(1))

abbreviation \<open>buddy_lists \<equiv> the (label_to_address l \<alpha> ''buddy_lists'')\<close>

schematic_goal unfold_semantics:
  shows \<open>instr_semantics semantics instr_sig = ?x\<close>
  by (simp add: semantics_def simp_rules)

fun buddy_flag_annotation :: flag_annotation where
  \<open>buddy_flag_annotation loc = (if loc \<in> {
    (0, 8), \<comment> \<open>buddy_large_avail\<close> \<comment> \<open>only one needed for buddy_large_avail by itself\<close>
    (2, 22) \<comment> \<open>modified buddy_get\<close>
  } then {flag_cf, flag_zf} else if loc \<in> {
    (0, 18), \<comment> \<open>needed by buddy_get\<close>
    (2, 27)
  } then {flag_zf} else {})\<close>

text \<open>
  The step function fetches the next instruction and executes it.
  This matches exactly what method rewrite\_one\_instruction is able to rewrite.
  Need to switch to learned semantics rather than manual eventually?
\<close>
definition step :: \<open>(unit, state) se\<close> where
  \<open>step \<sigma> \<equiv>
    let' t = text_sections \<alpha>!(nat (ts \<sigma>));
         i = instructions t!(nat (pc \<sigma>));
         \<sigma> = exec_instr buddy_flag_annotation semantics i \<sigma>
    in
      Some ((), \<sigma>)\<close>

lemma wps_stepI[wps_intros]:
  assumes \<open>let' t = text_sections \<alpha>!(nat (ts \<sigma>));
                i = instructions t!(nat (pc \<sigma>));
                \<sigma> = exec_instr buddy_flag_annotation semantics i \<sigma>
           in
             Q () \<sigma>\<close>
  shows \<open>wps step Q \<sigma>\<close>
  using assms
  unfolding step_def
  by (auto simp add: Let'_def Let_def wps_def)

definition wf_state :: \<open>state \<Rightarrow> bool\<close> where
  \<open>wf_state _ = True\<close>

definition location :: \<open>state \<Rightarrow> int \<times> int\<close> where
  \<open>location \<sigma> \<equiv> (ts \<sigma>, pc \<sigma>)\<close>

definition until :: \<open>(int \<times> int) set \<Rightarrow> state \<Rightarrow> bool\<close>
  where \<open>until H \<sigma> \<equiv> \<exists>(ts\<^sub>H, pc\<^sub>H) \<in> H. location \<sigma> = (ts\<^sub>H, pc\<^sub>H - 1)\<close>

text \<open>
   suggested @{text \<open>(sublist n m xs = []) = (Suc m \<le> n \<or> length xs \<le> n)\<close>} for efficiency, but
  that unfortunately doesn't work.
\<close>
lemma sublist_empty: (* TODO: move elsewhere eventually *)
  assumes \<open>n \<ge> length xs\<close>
    and \<open>m \<ge> length xs\<close>
  shows \<open>sublist n m xs = []\<close>
  using assms unfolding sublist_def
  by simp

end

declare plus_less_left_cancel_nowrap[simp add]
lemma x_less_x_plus_y[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
  shows \<open>x \<le> x + y\<close>
  apply (rule plus_minus_no_overflow_ab[of x "max_word::'a::len word" y,OF assms])
  by auto
lemma x_plus_y_less_x[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
    and \<open>y > 0\<close>
  shows \<open>x + y \<le> x \<longleftrightarrow> False\<close>
  using assms x_less_x_plus_y
  by fastforce
lemma less_max_word_minus[simp]:
  fixes x y z :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
     and \<open>y \<ge> z\<close>
   shows \<open>x \<le> max_word - z\<close>
  apply (rule order_trans[OF assms(1)])
  using assms
  by simp
lemma plus_lt_left_cancel_nowrap[simp]: \<open>x \<le> x + y' \<Longrightarrow> x \<le> x + y \<Longrightarrow> x + y' < x + y \<longleftrightarrow> y' < y\<close>
  for x y y' :: \<open>'a::len0 word\<close>
  by uint_arith
lemma plus_lt_right_cancel_nowrap[simp]: \<open>x \<le> x + y' \<Longrightarrow> x \<le> x + y \<Longrightarrow> y' + x < y + x \<longleftrightarrow> y' < y\<close>
  for x y y' :: \<open>'a::len0 word\<close>
  by uint_arith
lemma x_lt_x_plus_y[simp]:
  fixes x y :: \<open>'a::len word\<close>
  assumes \<open>x \<le> max_word - y\<close>
    shows \<open>x < x + y \<longleftrightarrow> y > 0\<close>
proof -
  have \<open>x \<le> x + y\<close>
    apply (rule plus_minus_no_overflow_ab[of x \<open>max_word::'a::len word\<close> y, OF assms(1)])
    by auto
  thus ?thesis
    apply (auto simp add: word_le_less_eq)
    by uint_arith
qed

context execution_context
begin

lemmas sub_overflow_flag_simps[simp] =
  sub_overflow_flag_def[of 0 0]
  sub_overflow_flag_def[of 0 1]
  sub_overflow_flag_def[of 0 \<open>numeral m\<close>]
  sub_overflow_flag_def[of 1 0]
  sub_overflow_flag_def[of 1 1]
  sub_overflow_flag_def[of 1 \<open>numeral m\<close>]
  sub_overflow_flag_def[of \<open>numeral n\<close> 0]
  sub_overflow_flag_def[of \<open>numeral n\<close> 1]
  sub_overflow_flag_def[of \<open>numeral n\<close> \<open>numeral m\<close>]
  for n m

lemmas sub_sign_flag_simps[simp] =
  sub_sign_flag_def[of 0 0]
  sub_sign_flag_def[of 0 1]
  sub_sign_flag_def[of 0 \<open>numeral m\<close>]
  sub_sign_flag_def[of 1 0]
  sub_sign_flag_def[of 1 1]
  sub_sign_flag_def[of 1 \<open>numeral m\<close>]
  sub_sign_flag_def[of \<open>numeral n\<close> 0]
  sub_sign_flag_def[of \<open>numeral n\<close> 1]
  sub_sign_flag_def[of \<open>numeral n\<close> \<open>numeral m\<close>]
  for n m
end

end
