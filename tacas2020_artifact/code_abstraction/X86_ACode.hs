{-# LANGUAGE PartialTypeSignatures #-}
module X86_ACode where


import X86_Datastructures
import Data.Graph hiding (edges)
import Data.List
import Data.Array
import Data.List.Unique
import Data.Maybe
import Debug.Trace
import qualified Data.Graph.SCC as SCC
import Control.Exception.Base
import qualified Data.Map as M
import Control.Monad
import Numeric (showHex)
import qualified Data.IntSet as IS

import Data.IORef
import System.IO.Unsafe


-- Set to putStrLn to enable debugging messages
to_log :: String -> IO ()
to_log = \s -> return ()
         -- putStrLn 

-- The abstract code:
data ACode a b = 
    BasicBlock a                              -- the 'a' is a node. Function node_to_block gives the block defined by two addresses
  | Seq (ACode a b) (ACode a b)               -- sequential blocks
  | While (ACode a b)                         -- while (true) { ... } statement
  | ITE (ACode a b) b (ACode a b) (ACode a b) -- if-then-else. The b is the type of the flags
  | Break [Int]
  | Continue
  | Skip
  | Call Int                                  -- a call to a common pattern identified by the int
  | WhileResume [(Int,ACode a b)]             -- in case of a while with multiple exits
  | UnexploredWhile [a] a                     -- used to keep while-loops unexplored. Should not be part of produced code.
  | ErrorInCode String                        -- error, should not be part of produced code.
  deriving (Eq, Show, Ord)


{--
counter2 = unsafePerformIO $ newIORef 0
incr_counter2 _ = unsafePerformIO $ do
  i <- readIORef counter2
  writeIORef counter2 (i+1)
  return i
--}

-- Pretty printing
show_block b = "[" ++ showHex (head b) "" ++ "->" ++ showHex (last b) "" ++ "]"

show_ACode :: (String -> a -> String) -> (b -> String) -> ACode a b -> String
show_ACode f g c = show_ACode' c "" True
 where
  show_ACode' (BasicBlock k) indent _ = f indent k 
  show_ACode' (Seq a1 a2) indent newlines = show_ACode' a1 indent newlines ++ "; " ++ (if newlines then "\n" else "") ++ show_ACode' a2 indent newlines
  show_ACode' (While a2) indent newlines = indent ++ "while True do\n" ++ show_ACode' a2 (indent ++ "  ") True ++ "\n" ++ indent ++ "od" 
  show_ACode' (ITE a1 flg a2 a3) indent newlines = show_ACode' a1 indent True ++ "; " ++ (if newlines then "\n" ++ indent else "") ++ "if " ++ g flg ++ " then\n" ++ show_ACode' a2 (indent ++ "  ") True ++ "\n" ++ indent ++ "else\n" ++ show_ACode' a3 (indent ++ "  ") True ++ "\n" ++ indent ++ "fi" -- ++ show (incr_counter2 0)
  show_ACode' (Break i) indent newlines = indent ++ "break " ++ (if i == [] then "" else showHex (head i) "")
  show_ACode' Skip indent newlines = indent ++ "skip"
  show_ACode' (Continue) indent newlines = indent ++ "continue"
  show_ACode' (ErrorInCode s) indent newlines = indent ++ "error: " ++ s
  show_ACode' (UnexploredWhile scc k) indent _ = indent ++ "unexplored while (entry-point " ++ f "" k ++ "): " ++ "[" ++ intercalate "," (map (f "") scc) ++ "]"
  show_ACode' (Call i) indent _ = indent ++ "call " ++ show i
  show_ACode' (WhileResume x) indent _ = intercalate "\n" (map (\(k,a) -> indent ++ "broken @ " ++ showHex k "" ++ " --> \n" ++ show_ACode' a (indent ++ "  ") True) x)

show_ACode_Int node_to_block = show_ACode (\i k -> i ++ show_block (node_to_block M.! k)) id

-- A graph is represented by nodes, keys, vertices.
-- A graph is built from an edge list :: [(node, key, [key])].
-- Nodes are the actual contents of the nodes of the graph. In our case, Nodes are Ints referring to Blocks via the mapping node_to_block.
-- Keys are static indentifiers of the nodes of type Int.
-- A vertex is an int dynamically generated when building a graph.
-- Thus, when modifying the graph, nodes and keys remain the same whereas vertices can change.
type Node = Int
type Key = Int

-- Convert a vertex to a key. The first argument is generated by function graphFromEdges.
vertex_to_key :: _ -> Vertex -> Int
vertex_to_key nodeFromVertex v = let (_,key,_) = nodeFromVertex v in key

-- Pretty printing
show_key node_to_block k = "(" ++ show k ++ "," ++ show_block (node_to_block M.! k) ++ ")"

show_maybe_key node_to_block Nothing = ""
show_maybe_key node_to_block (Just k) = show_key node_to_block k




-- modify an edgeList to create a subgraph determined by the given set of keys
prune_edgeList :: [Key] -> [(Node, Key, [Key])] -> [(Node, Key, [Key])]
prune_edgeList keys edgeList = catMaybes (map (take_edges_from keys) edgeList)
 where
  take_edges_from keys (n,k,children) =
    if k `elem` keys then Just (n,k,filter (\v -> v `elem` keys) children)
    else Nothing

-- given an edgeList and a subgraph determined by keys, return the partitioning into SCCs.
mk_sccs :: _ -> [Key] -> [[Key]]
mk_sccs edgeList keys =
  let -- build a subgraph
      edgeList' = prune_edgeList keys edgeList 
      (graph', nodeFromVertex', vertexFromKey') = graphFromEdges edgeList' 
      -- Partition the new graph
      (sccs',vertex_to_scc_id') = SCC.scc graph' in
    map (scc_to_keys nodeFromVertex') sccs'
 where
  scc_to_keys nodeFromVertex' (i,vs) = map (vertex_to_key nodeFromVertex') vs

-- return the children of the given node (identified by the key)
get_children :: _ -> Key -> [Key]
get_children (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) k =
  case vertexFromKey k of
    Nothing -> error "Key not in graph"
    Just v -> map (vertex_to_key nodeFromVertex) (graph ! v)

-- return the parents of the given node (identified by the key)
get_parents :: _ -> Key -> [Key]
get_parents (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) k =
  case vertexFromKey k of
    Nothing -> error "Key not in graph"
    Just v -> map (vertex_to_key nodeFromVertex) (transposeG graph ! v)

-- This function returns, given a subgraph determined by keys and its partitioning into SCCs,
-- a mapping from keys to Maybe key, such that:
-- if key k is mapped to Just k', then k' is the first descendant of k such that all paths starting at k lead to k' (k' /= k).
-- if key k is mapped to Nothing, then there is no such descendant
-- Two examples:
-- consider a graph a --> b --> c and a --> c. Then a is mapped to c. This example corresponds to an if-statement without else.
-- consider a graph with a cycle a --> b --> c --> a and an exit c --> d. Then a is mapped to d. This corresponds to a while loop.
-- k' determines is used to determine the next sequential step. 
-- For example 1, code abstraction produces: IF a THEN b ELSE skip ; c.
-- For example 2: WHILE { a ; b ; IF c THEN break ELSE skip } ; d
-- This function is similar to, but different from the notion of "immediate post-dominator".
-- NOTE: this function is relatively expensive, i.e., O(n^2)
ipdoms :: _ -> [Key] -> [[Key]] -> _
ipdoms (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) keys sccs start =
  let pdoms = M.fromList (zip keys (map IS.singleton keys))
      pdoms' = mk_pdoms pdoms
      ipdoms' = M.mapWithKey (get_ipdom pdoms') pdoms' in
    ipdoms'
 where
  get_ipdom pdoms k ks =
    let ks' = IS.toList (IS.delete k ks) in
      find (\k' -> not (dominated pdoms k' ks')) ks'
  dominated pdoms k ks = any (\k' -> not (k' == k) && IS.member k (pdoms M.! k')) ks
  mk_pdoms pdoms = let pdoms' = update_pdoms pdoms in
    if pdoms' == pdoms then
      pdoms
    else 
      mk_pdoms pdoms' 
  update_pdoms pdoms = 
      foldl update_pdoms' pdoms sccs
  update_pdoms' pdoms scc =
    let children = concatMap (get_children (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block)) scc in
      if any (\c -> c `notElem` keys) children then
        pdoms
      else let cs = filter (\k -> k `notElem` scc && Just k /= start) children in
        foldl (\lpdoms k -> M.adjust (update_key pdoms cs) k lpdoms) pdoms scc
  update_key pdoms cs curr =
    case cs of
      [] -> curr
      _ -> IS.union curr $ foldl1 IS.intersection (map (\k -> pdoms M.! k) cs)



---------------------
-- code extraction --
---------------------

-- Extract code, given the current scc (i.e., the current subgraph) and the current key.
-- 1.) split the current subgraph into SCCs.
-- 2.) if the SCC is trivial (i.e., one element) then the current sugraph indicates a while loop.
--     In that case, SCCs are rebuild after removing the current key and then adding the current key as a separate SCC.
-- 3.) Build the ipdoms relation based on the current SCCs. This provides information on which parts should be sequentially extracted.
-- 4.) Extract a sequence of code statements: a0 ; a1 ; a2 ; ... where ipdoms maps a(n) to a(n+1)
extract_code (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc current_key = do
  to_log "extract_code"
  let sccs = mk_sccs edgeList current_scc 
  if length sccs == 1 then do
    to_log "CFG is one big loop"
    let sccs = [current_key] : mk_sccs edgeList (delete current_key current_scc)
    let curr_ipdoms = ipdoms (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc sccs (Just current_key)
    extract_seq (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc current_key current_key sccs curr_ipdoms
  else do
    let curr_ipdoms = ipdoms (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc sccs Nothing
    extract_seq (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc current_key current_key sccs curr_ipdoms

extract_seq :: (_,[((Int,Int),String)],_,_,_,_) -> [Key] -> Key -> Key -> [[Key]] -> M.Map Key (Maybe Key) -> _
extract_seq (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc current_key start_key sccs curr_ipdoms = do
  to_log "extract_seq"
  to_log $ "current_key == " ++ show_key node_to_block current_key
  -- the joint is the node of the next sequential statement, if any
  let joint_key = curr_ipdoms M.! current_key
  to_log $ "curr_ipdoms[current_key] == " ++ show_maybe_key node_to_block joint_key

  -- the current code statement
  code1 <- extract_statement current_key joint_key True
  case joint_key of
    Nothing -> return code1
    Just next_key -> do
      -- proceed with the next code statement
      code2 <- extract_seq (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_scc next_key start_key sccs curr_ipdoms
      return $ Seq code1 code2
 where
  extract_statement current_key joint_key fresh = do
    -- extract one statement, obtained by recursively extracting code until the joint is found
    to_log "extract_statement"
    to_log $ "current_key == " ++ show_key node_to_block current_key
    to_log $ "joint_key == " ++ show_maybe_key node_to_block joint_key

    case find (\scc -> current_key `elem` scc) sccs of
     Nothing -> do
        -- the current subgraph has been exitted: a Break from a While loop
        to_log "current_key not in scc"
        let exit_address = head (node_to_block M.! current_key)
        -- let ps = get_parents (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_key
        return $ Break (if Just current_key == joint_key then [] else [exit_address])
     Just scc ->
      if Just current_key == joint_key then do
        -- the joint has been found, so terminate extraction of the current statement
        to_log "found joint"
        return $ Skip
      else if not fresh && current_key == start_key then do
        -- the initial node has been found, indicating a cycle. Extract a continue.
        to_log "found start"
        return $ Continue
      else if length scc > 1 then do
        -- a non-trivial SCC indicates a while loop
        extract_while current_key joint_key scc
      else if current_key `notElem` current_scc then do
        -- the current SCC has been exitted: a Break from a While loop
        to_log "found node out of current scc"
        let ps = assert (False) $ get_parents (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_key
        return $ assert (False) $ Break ps
      else case get_children (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) current_key of
        [] -> do 
          -- no children: terminate
          to_log "stop"
          return $ BasicBlock current_key
        [k1] ->
          if k1 == current_key then do
            to_log("self-loop without exit")
            return $ While (BasicBlock current_key) 
          else do 
            -- one child: recursively extract the next statement
            to_log("seq (one child, trivial scc)")
            code <- extract_statement k1 joint_key False
            return $ Seq (BasicBlock current_key) code
        [k1,k2] ->
          if current_key `elem` [k1,k2] then do
            -- a specific case: a --> a && a --> b
            to_log "self-loop"
            let exit_key = if current_key == k1 then k2 else k1
            code <- extract_statement exit_key joint_key False
            return $ Seq (While (ITE (BasicBlock current_key) (get_flg current_key exit_key) (Break [current_key]) Skip)) code
          else do
            to_log("if (two children, trivial scc)")
            -- an if statement
            extract_if current_key joint_key k1 k2
  extract_while current_key joint_key scc = do
    -- extract the next sequential statement
    let next_key = curr_ipdoms M.! current_key
    code <- case next_key of
      Nothing -> do
        return $ id
      Just joint_key' -> do
        code1 <- extract_statement joint_key' joint_key False
        return $ (\code -> Seq code code1)
    -- consider the set of exits from this loop, and the children outside fo the current loop
    let exit_keys = filter (is_exit_key (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) scc) scc
    let exit_children = map (fst . get_exit_child (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) scc) exit_keys
    to_log $ show (show_key node_to_block current_key, map (show_key node_to_block) exit_keys)
    code1 <- case exit_children of
      []  -> return $ assert (Nothing == next_key) id
      _ -> do
        if map Just exit_children == [next_key] then
          -- a while loop with one break, resuming at the expected point
          return $ id
        else if length exit_children == 1 then do
          -- a while loop with one break, extract the statement that leads from that break to next_key
          code2 <- extract_statement (head exit_children) next_key False
          return (\code -> Seq code code2)
        else do
          -- for each exit-child, extract a code statement until next_key.
          -- Return a WhileResume statement that for each exit provides the code to be executed before the next statement.
          codes <- mapM (\k -> extract_statement k next_key False) exit_children
          let exit_addresses = map (\k -> head (node_to_block M.! k)) exit_children
          let code2 = WhileResume $ filter (not . (==) Skip . snd) $ nub $ zip exit_addresses codes
          return (\code -> Seq code code2)
    return $ code $ code1 $ While (UnexploredWhile (sort scc) current_key)
  extract_if current_key joint_key k1 k2 =
    case curr_ipdoms M.! current_key of
      Nothing -> do
        -- an if-statement without next sequential statement
        to_log $ "If without next joint"
        code1 <- extract_statement k1 joint_key False
        code2 <- extract_statement k2 joint_key False
        return $ (ITE (BasicBlock current_key) (get_flg current_key k1) code1 code2)
      Just joint_key' -> do
        -- an if-statement with next sequential statement
        to_log $ "Loop with next joint"
        code1 <- extract_statement k1 (Just joint_key') False
        code2 <- extract_statement k2 (Just joint_key') False
        code3 <- extract_statement joint_key' joint_key False
        return (Seq (ITE (BasicBlock current_key) (get_flg current_key k1) code1 code2) code3)
  get_flg k0 k1 = snd $ fromJust $ find (\(e,flg) -> e == (k0,k1)) edge_info

-- Takes as input a graph, an SCC and a vertex.
-- Assuming the vertex is an exit vertex, returns the children: the out-child first, the in-child second.
get_exit_child :: _ -> [Key] -> Key -> (Key,Key)
get_exit_child (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) scc k =
  case get_children (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) k of
    [c1, c2] -> if (c1 `elem` scc && not (c2 `elem` scc)) then (c2,c1) else if (not (c1 `elem` scc) && c2 `elem` scc) then (c1,c2) else assert False (k,k)
    _ -> assert False (k,k)

-- Takes as input a graph, an SCC and a key.
-- Returns true iff the key is an exit key, i.e., has one child in the scc and one child out.
is_exit_key (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) scc k =
  case get_children (edgeList,edge_info,graph,nodeFromVertex,vertexFromKey,node_to_block) k of
    [k1, k2] -> (k1 `elem` scc && not (k2 `elem` scc)) || (not (k1 `elem` scc) && k2 `elem` scc)
    _ -> False

-------------------------
-- end code extraction --
-------------------------



-----------------------
-- code modification --
-----------------------
-- remove unnecessary skips
remove_skips (Seq Skip Skip) = Skip
remove_skips (Seq a1 Skip) = remove_skips a1
remove_skips (Seq Skip a2) = remove_skips a2
remove_skips (Seq a1 a2) = Seq (remove_skips a1) (remove_skips a2)
remove_skips (While a2) = While (remove_skips a2)
remove_skips (ITE a1 flg a2 a3) = ITE (remove_skips a1) flg (remove_skips a2) (remove_skips a3)
remove_skips (WhileResume x) = if length x == 0 then Skip else let (is,as) = unzip x in WhileResume (zip is (map remove_skips as))
remove_skips a = a

-- remove unnecessary continues
remove_continue (While a2) = While (remove_continue_at_end (remove_continue a2))
remove_continue (Seq a1 a2) = Seq (remove_continue a1) (remove_continue a2)
remove_continue (ITE a1 flg a2 a3) = ITE (remove_continue a1) flg (remove_continue a2) (remove_continue a3)
remove_continue (WhileResume x) = let (is,as) = unzip x in WhileResume (zip is (map remove_continue as))
remove_continue a = a

remove_continue_at_end (Seq a1 Continue) = remove_continue_at_end a1
remove_continue_at_end (Seq a1 a2) = Seq a1 (remove_continue_at_end a2)
remove_continue_at_end (ITE a1 flg a2 a3) = ITE a1 flg (remove_continue_at_end a2) (remove_continue_at_end a3)
remove_continue_at_end (WhileResume x) = let (is,as) = unzip x in WhileResume (zip is (map remove_continue_at_end as))
remove_continue_at_end a = a

-- apply associativity of Seq: Seq (Seq a b) c = Seq a (Seq b c)
assoc_seq (Seq (Seq a b) c) = assoc_seq (Seq a (Seq b c))
assoc_seq (Seq a b) = Seq (assoc_seq a) (assoc_seq b)
assoc_seq (ITE a flg b c) = ITE (assoc_seq a) flg (assoc_seq b) (assoc_seq c) 
assoc_seq (While b) = While (assoc_seq b)
assoc_seq (WhileResume x) = let (is,as) = unzip x in WhileResume (zip is (map assoc_seq as))
assoc_seq a = a

-- apply all code modifiers 
modify_acode = remove_continue . remove_skips . assoc_seq


-- remove unnecessary IDs after breaks
-- This is just for presentation, and should only be applied at the very end after all code abstraction has finished.
remove_unnec_break_IDS a = remove_skips $ remove_unnec_break_IDS' a (concatMap get_break_IDs $ filter_ACode isWhileResume a)
 where
   isWhileResume (WhileResume _) = True
   isWhileResume _ = False
   get_break_IDs (WhileResume x) = fst $ unzip x
   remove_unnec_break_IDS' (Break is) ids = Break $ filter (`elem` ids) is
   remove_unnec_break_IDS' (While a) ids = While $ remove_unnec_break_IDS' a ids
   remove_unnec_break_IDS' (Seq a b) ids = Seq (remove_unnec_break_IDS' a ids) (remove_unnec_break_IDS' b ids)
   remove_unnec_break_IDS' (ITE a flg b c) ids = ITE (remove_unnec_break_IDS' a ids) flg (remove_unnec_break_IDS' b ids) (remove_unnec_break_IDS' c ids)
   remove_unnec_break_IDS' (WhileResume x) ids = let (is,as) = unzip x in WhileResume (zip is (map (\a -> remove_unnec_break_IDS' a ids) as))
   remove_unnec_break_IDS' a ids = a


---------------------------
-- end code modification --
---------------------------



---------------------
-- common patterns --
---------------------

-- enumerate all common patterns found within a code statement
patterns (Seq a b) = (Seq a b) : (patterns a ++ patterns b)
patterns (ITE a flg b c) = (ITE a flg b c) : (patterns a ++ patterns b ++ patterns c)
patterns (While b) = (While b) : patterns b
patterns (WhileResume x) = concatMap patterns (snd (unzip x))
patterns (BasicBlock _) = [] -- one basic block is not considered a pattern
patterns Continue = []
patterns (Break _) = []
patterns Skip = []
patterns a = [a]

pattern_contains_break_or_continue (Seq a b) = pattern_contains_break_or_continue a || pattern_contains_break_or_continue b
pattern_contains_break_or_continue (ITE a flg b c) = pattern_contains_break_or_continue a || pattern_contains_break_or_continue b || pattern_contains_break_or_continue c
pattern_contains_break_or_continue (Break _) = True
pattern_contains_break_or_continue Continue = True
pattern_contains_break_or_continue _ = False

-- return the size of the pattern, i.e., the number of basic blocks.
-- Works for sequences only, i.e., a;b;c ==> 3.
-- For other code, an arbitrary large value is returned.
pattern_size (Seq a b) = pattern_size a + pattern_size b
pattern_size (Break _) = 0
pattern_size Skip = 0
pattern_size Continue = 0
pattern_size (BasicBlock _) = 1
pattern_size _ = 42

common_patterns a =
  let ps = filter (\p -> pattern_size p > 3) $ filter (not . pattern_contains_break_or_continue) $ patterns a -- TODO make 3 a config option?
      ps' = repeated ps in
    filter (not . included_in_other ps') ps'
 where
    included_in_other ps a = any (\b -> a `elem` delete b (patterns b)) ps


-- Let pattern_map be a mapping from common patterns (of type ACode) to Int, that map a statement a' to int f
-- Replace any occurence of a' in a by Call f
replace_common_patterns :: M.Map (ACode Int String) Int -> ACode Int String -> ACode Int String
replace_common_patterns pattern_map a =
  case M.lookup a pattern_map of
    Nothing -> replace_common_patterns' a 
    Just f -> Call f 
 where
  replace_common_patterns' (Seq a b) = Seq (replace_common_patterns pattern_map a) (replace_common_patterns pattern_map b)
  replace_common_patterns' (ITE a flg b c) = ITE (replace_common_patterns pattern_map a) flg (replace_common_patterns pattern_map b) (replace_common_patterns pattern_map c)
  replace_common_patterns' (While b) = While (replace_common_patterns pattern_map b)
  replace_common_patterns' (WhileResume x) = let (is,as) = unzip x in WhileResume (zip is (map replace_common_patterns' as))
  replace_common_patterns' a = a

-- A find function that traverses a code statement
find_ACode :: (ACode Int String -> Bool) -> ACode Int String -> Maybe (ACode Int String) 
find_ACode f a = if f a then Just a else find_ACode1 a
 where
  find_ACode1 (Seq a b) = find_ACode_many [a,b]
  find_ACode1 (ITE a flg b c) = find_ACode_many [a,b,c]
  find_ACode1 (While b) = find_ACode f b
  find_ACode1 (WhileResume x) = find_ACode_many (snd (unzip x))
  find_ACode1 _ = Nothing
  find_ACode_many [] = Nothing
  find_ACode_many (a:as) =
    case find_ACode f a of
      Nothing -> find_ACode_many as
      Just a -> Just a

-- A filter function that traverses a code statement
filter_ACode :: (ACode a b -> Bool) -> ACode a b-> [ACode a b]
filter_ACode f a = (if f a then [a] else []) ++ filter_ACode1 a
 where
  filter_ACode1 (Seq a b) = filter_ACode_many [a,b]
  filter_ACode1 (ITE a flg b c) = filter_ACode_many [a,b,c]
  filter_ACode1 (While b) = filter_ACode f b
  filter_ACode1 (WhileResume x) = filter_ACode_many (snd (unzip x))
  filter_ACode1 _ = [] 
  filter_ACode_many = concatMap (filter_ACode f)

-------------------------
-- end common patterns --
-------------------------



----------------------
-- code abstraction --
----------------------

-- code abstraction is done in steps, not all at once.
-- Function call_extract_code calls function extract_code which recursively goes through the CFG, but does not explore while loops.
-- The first call of function code_abstraction simply calls extract_code.
-- Subsequent calls search for an unexplored while, and apply function extract_code on the body of that while.
-- A map m is maintained, from ACode statements to Ints.
-- Common patterns are added to this map and in the abstract code they are replaced by "calls" to that common pattern.
code_abstraction :: Config -> _ -> Int -> M.Map (ACode Int String) Int -> IO (M.Map (ACode Int String) Int)
code_abstraction config (globals@(_,_,graph,nodeFromVertex,_,node_to_block)) start m = do
  to_log "code_abstraction"
  if M.null m then do
    let keys = map (vertex_to_key nodeFromVertex) (vertices graph)
    (m',code) <- call_extract_code config globals keys start m 
    return $ M.insert code (M.size m') m'
  else case find_next isUnexploredWhile (M.toList m) of
    Nothing -> do
      to_log "done!"
      return m
    Just (UnexploredWhile scc k) -> do
      let p = UnexploredWhile scc k
      case find_next (isWhileOf p) (M.toList m) of
        Nothing -> error $ "Cannot find entry of unexplored while."
        Just (While b) -> do
          to_log $ "next pattern = " ++ show_ACode_Int node_to_block (While b)
          (m',code) <- call_extract_code config globals scc k m 
          let m'' = M.mapKeys (modify_acode . replace_pattern p code) m'
          return $ assert (m'' /= m) m''
 where
  find_next _ [] = Nothing
  find_next pred ((a,f):m) =
    case find_ACode pred a of
      Nothing -> find_next pred m
      Just p -> Just p

  isWhileOf a (While (Call f)) = case M.lookup a m of
    Nothing -> False
    Just f' -> f' == f
  isWhileOf a (While a') = a == a'
  isWhileOf _ _ = False

  isUnexploredWhile (UnexploredWhile _ _) = True
  isUnexploredWhile _ = False
  replace_pattern p code (Seq a b) = Seq (replace_pattern p code a) (replace_pattern p code b)
  replace_pattern p code (ITE a flg b c) = ITE (replace_pattern p code a) flg (replace_pattern p code b) (replace_pattern p code c)
  replace_pattern p code (While b) = While (replace_pattern p code b)
  replace_pattern p code (WhileResume x) = let (is,as) = unzip x in WhileResume (zip is (map (replace_pattern p code) as))
  replace_pattern p code a = if a == p then code else a

call_extract_code config (globals@(_,_,_,_,_,node_to_block)) keys start m = do
  -- extract code
  code <- extract_code globals keys start
  -- modify code
  let code' = modify_acode code
  -- find and substitute patterns with function calls. Disabled by default.
  if False {-- extract_calls config --} then do
    let f = M.size m
    let ps = M.fromList (zip (common_patterns code') [f..])
    let code'' = replace_common_patterns ps code'
    to_log $ show_ACode_Int node_to_block code''
    to_log $ "Found patterns: " ++ show (length ps)
    let m' = M.union m ps
    return (m',code'')
  else
    return (m, code')


-- run code abstraction iteratively.
-- if m == Nothing then run until a fixpoint has been reached. This is the default.
-- For debugging, m can be set to Just i. In that case, i iterations are run.
run_code_abstraction config globals start (Just 0) m = return m
run_code_abstraction config globals start n m = do
  m' <- code_abstraction config globals start m
  if m == m' then do
    to_log "done!!"
    return m'
  else
    let n' = liftM (\n -> n - 1) n in
      run_code_abstraction config globals start n' m'

--------------------------
-- end code abstraction --
--------------------------



show_acode_map_entry node_to_block name a f str = 
  "Function " ++ show f ++ " of " ++ name ++ ":\n"
  ++ show_ACode_Int node_to_block a
  ++ "\n\n"
  ++ str

-- apply code abstraction to the given cfg
cfg_to_acode :: Config -> Maybe Int -> (String, Int, [(Int, Int, [Int])], _, M.Map Int [Int], Int -> Instr) -> _
cfg_to_acode config iters (name, start, edgeList, edgeInfo, node_to_block,_) = do
  -- build the graph
  let (graph, nodeFromVertex, vertexFromKey) = graphFromEdges edgeList
  to_log $ show graph

  m <- run_code_abstraction config (edgeList, edgeInfo,graph, nodeFromVertex, vertexFromKey,node_to_block) start iters M.empty
  let m' = M.mapKeys remove_unnec_break_IDS m
  putStrLn (M.foldrWithKey (show_acode_map_entry node_to_block name) "" m')
  return m'





-----------------------------
--GENERIC TRAVERSAL FUNCTIONS
-----------------------------
map_acode_generic :: (block -> [block] -> block) -> (flg -> flg) -> ACode block flg -> ACode block flg
map_acode_generic f g = map_acode' []
 where
  map_acode' nxt (BasicBlock b) = BasicBlock (f b nxt)
  map_acode' nxt (Seq a b) = Seq (map_acode' (acode_nxt b) a) (map_acode' nxt b)
  map_acode' nxt (ITE a flg b c) = ITE (map_acode' (acode_nxt b ++ acode_nxt c) a) (g flg) (map_acode' nxt b) (map_acode' nxt c)
  map_acode' nxt (While b) = While $ map_acode' (acode_nxt b ++ nxt) b
  map_acode' nxt (WhileResume x) =
    let (is,as) = unzip x 
        as' = map (map_acode' nxt) as in
      WhileResume (zip is as')
  map_acode' _ a = a

map_acode_blocks f = map_acode_generic f id


traverse_acode :: (block -> Int -> Maybe Bool -> [block] -> r) -> ACode block flg -> [r]
traverse_acode f = snd . traverse_acode' 0 Nothing []
 where
  traverse_acode' i cond nxt (BasicBlock b) = (i+1,[f b i cond nxt])
  traverse_acode' i cond nxt (Seq a b) =
    let (i0,results0) = traverse_acode' i cond (acode_nxt b) a
        (i1,results1) = traverse_acode' i0 Nothing nxt b in
      (i1, results0 ++ results1)
  traverse_acode' i cond nxt (ITE a flg b c) =
    let (i0,results0) = traverse_acode' i cond (acode_nxt b ++ acode_nxt c) a 
        (i1,results1) = traverse_acode' i0 (Just True) nxt b
        (i2,results2) = traverse_acode' i1 (Just False) nxt c in
      (i2, results0 ++ results1 ++ results2)
  traverse_acode' i cond nxt (While b) = traverse_acode' i cond (acode_nxt b ++ nxt) b
  traverse_acode' i cond nxt (WhileResume x) =
    let (is,as) = unzip x in
      foldl f (i,[]) as
   where
    f (i,results) a =
      let (i0,results0) = traverse_acode' i cond nxt a in
        (i0, results++results0)
  traverse_acode' i _ _ _ = (i,[])

acode_nxt (BasicBlock b) = [b]
acode_nxt (Seq a _) = acode_nxt a
acode_nxt (ITE a _ _ _) = acode_nxt a
acode_nxt (While b) = acode_nxt b
acode_nxt (WhileResume x) = let (_,as) = unzip x in concatMap acode_nxt as
acode_nxt _ = []
